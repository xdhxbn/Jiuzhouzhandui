#中期考核文档
=============
##学习内容
===
========
唐颢铭：<br>
一、具体学习内容总结<br>

建模模块<br>
草图与特征：参数化草图绘制（几何约束）、基础实体生成（拉伸/旋转/扫掠）、高级曲面处理（修补/放样）。<br>
工具效率：快捷键（如S键搜索命令）、自定义面板管理。<br>

焊接模块<br>
工作流：焊件环境切换、3D草图框架绘制<br>
实战场景：金属框架/机械臂底座等刚性结构设计，电路基本焊接<br>

3D打印模块<br>
处理：壁厚分析（确保≥喷嘴直径1.2倍）、支撑优化（树状支撑减少耗材）。<br>
导出与切片：STL文件导出（高分辨率设置）、切片参数配置（层厚0.1-0.2mm、填充率15-20%）。<br>
打印技巧：防翘曲措施（如裙边启用）。<br>

二、成果总结<br>

建模成果：<br>
实现从草图到复杂实体（如机械零件）的构建。<br>

焊接成果：<br>
完成小车内的基础电路焊接。<br>

3D打印成果：<br>
预处理模型以避免打印失败（如悬垂支撑处理），优化切片设置节省30%以上耗材。<br>
完成从Fusion 360到打印成品的端到端流程（导出→切片→打印验证）。<br>

=========
程锦宏<br>
#### **一、 主要学习内容（知识体系）**

本阶段的学习主要围绕以下几个方面展开：

**1. 嵌入式系统概述**
   - **核心概念**：理解了嵌入式系统是“专用于特定应用的计算机系统”，其特点包括专用性、实时性、可靠性、功耗敏感以及资源受限（CPU主频、内存、存储空间等）。
   - **系统组成**：掌握了嵌入式系统由**硬件层**（处理器、存储器、I/O设备）和**软件层**（操作系统、应用程序）共同构成。
   - **应用领域**：认识到嵌入式系统广泛应用于智能家居、工业控制、汽车电子、医疗设备、消费电子等各个领域。

**2. 嵌入式硬件核心**
   - **微控制器（MCU）**：作为学习重点，深入理解了MCU的结构。其将CPU、RAM、ROM（Flash）、定时器、中断控制器及多种I/O接口（如GPIO, UART, I2C, SPI, ADC/DAC）集成在单一芯片上。
     - **CPU架构**：重点学习了**ARM Cortex-M系列**（如M3, M4）内核，了解了其寄存器组、操作模式（线程模式、处理模式）和指令集（Thumb-2）的特点。
     - **存储器结构**：理解了Flash（存储程序代码、常量）、RAM（存储变量、堆栈）、以及各类外设寄存器的映射关系（内存映射I/O）。
   - **通用输入输出（GPIO）**：掌握了GPIO的基本工作原理，包括：
     - **引脚模式配置**：推挽输出、开漏输出、上拉/下拉输入、浮空输入等。
     - **读写操作**：学习如何通过设置/清除寄存器来控制引脚电平，以及读取输入引脚的状态。这是控制LED、按键等最基本外设的基础。
   - **时钟系统**：理解了时钟是MCU的“脉搏”，学习了内部RC振荡器（HSI）与外部晶体振荡器（HSE）的区别，以及如何通过PLL倍频得到更高的系统时钟（SYSCLK）。

**3. 嵌入式软件基础**
   - **交叉开发环境**：建立了**宿主机（PC）** 与**目标板（开发板）** 的开发模型。学会了在PC上编写、编译代码，然后通过调试器烧录到目标板运行。
   - **编程语言**：以**C语言**为核心，重点复习和巩固了：
     - 位运算（与、或、非、异或、移位），用于精确操控寄存器特定位。
     - 指针与内存地址的直接操作，特别是函数指针的应用。
     - `volatile`关键字，防止编译器优化对硬件寄存器操作的代码。
     - 结构体与宏定义，用于高效地组织和管理寄存器映射。
   - **启动流程**：学习了从芯片上电到执行`main()`函数的过程：
     1. 从固定地址获取栈指针初始值（MSP）。
     2. 从复位向量地址获取程序计数器（PC）初始值，即复位处理函数。
     3. 执行系统初始化代码（如`SystemInit`），配置时钟。
     4. 调用C库的`__main`，初始化数据段（Data）、清零BSS段，最后跳转到用户的`main()`函数。
   - **固件库与HAL库**：学习了使用芯片厂商提供的标准库（如STM32的HAL库或标准外设库）进行开发，通过调用API函数来配置和使用外设，提高了开发效率和代码可移植性。

**4. 核心外设与通信协议**
   - **中断系统**：理解了中断是处理异步事件的关键机制。
     - **NVIC（嵌套向量中断控制器）**：学习了如何配置中断优先级（抢占优先级和子优先级）和使能中断。
     - **外部中断（EXTI）**：学习了如何配置GPIO引脚使其能够触发中断。
   - **定时器（TIM）**：学习了基本定时器、通用定时器和高级定时器的功能，掌握了：
     - 定时计数原理（计数器、预分频器、自动重载寄存器）。
     - 实现精确延时、产生PWM波形（控制舵机、电机）等方法。
   - **串行通信协议**：
     - **UART（通用异步收发传输器）**：掌握了其异步、全双工、点对点的特点，理解了波特率、数据位、停止位、奇偶校验位等概念。学会了通过轮询和中断方式接收/发送数据。
     - **I2C（Inter-Integrated Circuit）**：理解了其基于时钟线（SCL）和数据线（SDA）的半双工、多主多从的通信方式。掌握了起始信号、停止信号、应答信号（ACK/NACK）的时序，以及通过设备地址进行寻址的机制。
     - **SPI（串行外设接口）**：理解了其基于时钟线（SCLK）、主出从入（MOSI）、主入从出（MISO）和片选（CS）的全双工、同步通信方式。掌握了其高速通信的特点。

**5. 嵌入式操作系统（RTOS）基础**
   - **基本概念**：了解了为什么需要RTOS，特别是在处理多任务、复杂应用时。
   - **核心机制**：初步学习了**任务/线程**、**任务调度**（基于优先级）、**任务间通信**（信号量、消息队列、互斥锁）和**时间管理**（滴答定时器）等基本概念。

**6. 开发与调试工具**
   - **集成开发环境（IDE）**：熟练使用了如Keil MDK-ARM或STM32CubeIDE等工具进行工程管理、代码编写和编译。
   - **调试器**：掌握了使用ST-Link、J-Link等调试工具进行**在线调试（ICD）**，包括单步执行、设置断点、查看变量和寄存器值、分析外设状态等。

#### **二、 实践项目与总结**

通过理论学习，我配合完成了以下基础实验以巩固知识：
1.  **GPIO控制LED流水灯**：熟悉了工程创建、GPIO配置和基本的延时函数。
2.  **按键中断控制LED**：实践了EXTI和NVIC的配置，深入理解了中断处理流程。
3.  **UART打印调试信息**：学会了如何通过串口与PC通信，是重要的调试手段。
4.  **通过I2C/SPI读取传感器数据**（如温湿度传感器SHT30、加速度计MPU6050）：实践了总线协议的驱动编写和数据读取。

#### **三、 总结与展望**

通过本阶段的学习，我系统地构建了嵌入式开发的知识框架，从硬件原理到软件编程，从寄存器操作到库函数使用，具备了独立完成简单嵌入式应用开发的能力。

下一阶段，我将计划在以下方面进行深入学习：
1.  **深入RTOS**：选择一个主流RTOS（如FreeRTOS），深入学习其内核原理，并完成多任务设计的综合项目。
2.  **复杂外设驱动**：学习并实践ADC/DAC、看门狗、DMA（直接存储器访问）等更复杂外设的应用。
3.  **低功耗设计**：学习MCU的低功耗模式及其应用场景。


## PS2通信模块
=====
  功能描述：该模块用于实现PS2接收器与stm32主板之间的通讯功能。为了保证通讯的实时性，决定采用非阻塞式编程，即通过计时器中断来按时与手柄通信，以免出现卡在程序某处导致不能及时接收信息的情况。后续迭代升级的计划是采用spI硬件自动通信并且用DMA自动转存PS2数据到结构体中，既节约软件资源，又提高了传输速度。<br>

=====
  开发历程：<br>
    10月9日：初期方案：<br>
    初期讨论后准备采用用软件模拟SPI通信，在主程序中调用PS2通信函数更新PS2结构体，再根据PS2结构体数据调整外设。
    后来为规范程序设计，方便合作，规定每个外设对应的模块设计一个对接PS2的函数，每个外设通过该函数从ps2中获得需要的数据存入自己的
    结构体中，再调用根据自己结构体调整自己的外设的函数，奠定了主程序框架的基础。<br>
    10月9日：遇到的问题之一：<br>
    首先是在写PS2通信函数的时候遭遇了问题。由于跟着江科大学的是标准库，群里的代码没法照搬，就开始着手写PS2通信程序。遇到的第一个
    问题是，由于以为SPI通讯外设都和江科大讲的一样，在最开始无论如何都无法实现通信，接收器也连不上。<br>
    10月9日：解决方案：<br>
    首先找客服搞清楚接收器闪烁代表什么。根据客服消息，确定了是程序没写对。之后找客服要数据手册，想办法搞明白了时序图的含义和一些表格
    的意思，明白了每个SPI外设虽然大体上通讯逻辑一样但一些细节，如从高位开始发送还是从低位开始发送，是不一样的，搞明白这个PS2手柄的通
    讯方式后成功解决了这个问题。<br>
    10月10日：遇到的问题之二：<br>
    在主程序的while()循环中的某个固定的位置调用PS2通信函数，虽然暂时没什么问题，但是随着主程序中运行的代码越来越多，可能不能及时地接
    收手柄的信息，不利于小车迭代升级，也不能保证通信的实时性。<br>
    10月10日：解决方案：<br>
    决定用定时器中断的方式，使用定时器，每过10ms就发起一次中断，进行与PS2的通信，这样保证了PS2通信的畅通，确保小车及时做出调整。<br>
    10月23日：下一步迭代优化方案：<br>
    经过学习，提出采用spI硬件自动通信并且用DMA自动转存PS2数据到结构体中，既节约软件资源，又极大的提升了传输速度，
    预计在二代机中实现。<br>

## 麦轮运动系统模块
=====
  功能描述：该模块用于实现通过PS2控制小车的方向，旋转以及运动速度。虽然理论上可以实现走任意角度斜线的功能，但是苦于定时器资源不够只能舍弃一部分功能，但是转向，上下左右平移，调控速度都没问题。<br>
  
=====
  开发历程：<br>
  10月13日：初期方案：<br>
    依照预定的框架，由小及大定义结构体，先定义了单个轮子的结构体，并写了控制轮子正转，反转和停止的函数，由于定时器有限就四个轮子统一一个速度，
    并将四个轮子结构体和方向参数，旋转参数和速度参数一起封装成了运动系统结构体，编写对应的初始化函数，读取PS2函数与调整外设函数，实现PS2传递
    信息给运动系统，运动系统控制轮子的分级控制结构，虽然这个过程显得有点拐来拐去的，但是便于之后修改代码和实现小车的迭代升级，比如万一要改引
    脚的话就改一下结构体初始化函数就好了，而且整个过程的思路会清楚一些。<br>
  10月13日：遇到的问题之一：<br>
    首先遇到了如何用手柄控制小车的速度与运动方式的问题，要求手柄对小车的控制要灵活并易于操作。<br>
  10月13日：解决方案：<br>
    我们想让小车可以调整一下速度的快慢，一个方案是通过上下左右的按键控制，按一下对应的方向键就向对应的方向加速，但是感觉太笨重了，于是想这研究
    一下摇杆，在搞清楚摇杆数据的原理之后，就开始着手制定控制的规则，原本想设计一个根据可以按照x与y的比例走任意方向的方案，但是由于外设不足只好
    放弃。经过讨论，左摇杆x方向的位移大小和y方向的位移大小谁大，就认为小车是在沿哪个轴运动，并且依据该方向上的位移，以一定比例放大，来调整PWM的
    占空比，从而调整速度。用右摇杆控制旋转方向，当x方向无位移时认为不旋转，右摇杆向右偏就是以顺时针转反之逆时针，速度由x方向偏移大小决定，且旋
    转命令的优先级大于平动命令。<br>
  10月14日：遇到的问题之二：<br>
    原本想直接通过运动结构体来调整运动，但是想到如果保持相同运动状态的话每次都要设置相同的参数太浪费软件资源了。<br>
  10月14日：解决方案：<br>
    在程序中设置了两个运动结构体，分别为car_now,car_last，最开始二者相同，随后开始将需要的PS2数据存入now中，之后进入调整运动的函数时，比较now
    与last中的数据是否一致，相同的话就不改，不同再改，且设计了运动状态时间的过渡状态，比如说，发现last表明之前小车再转动，会先停止转动，再重新配
    置，又比如如果last是向前转，now是反转，就先让电机停下来，再设置方向速度，避免在电机快速旋转时突然改变极性可能的对电机和电路的损伤，之后再把
    now中的数据转移到last来。<br>
  10月14日：下一步迭代优化方案：<br>
    会在测试中研究合适的占空比与算法，让运动过渡更平稳，起步更快，刹车更及时灵敏等。<br>


## 收集模块

<img width="864" height="496" alt="image" src="https://github.com/user-attachments/assets/6b6bb0c3-9933-4032-a8aa-aa344299bbec" />

=====
  功能描述：利用马达带动水车装置旋转，实现对小球的收集，利用斜坡作为导轨将被弹起的小球送到仓库。<br>
  
=====
  开发历程：<br>
  10月13日：初步设计思路：因为小车会有上下坡的动作，斜坡的存在会使小车整体被卡住，因此我们设计了伸缩结构的收集装置<br>
  10月14日到10月17日：迭代优化方案：就伸缩结构而言，第一代方案是利用齿轮齿条的传动作用将整个收集装置上下收缩移动，但是考虑到结构复杂以及容易卡住，第二代方案我们换成了利用两个舵机实现对收集装置的抬升，随后又还是觉得麻烦，所以我们的第三代收集装置是利用一个TT马达牵引两根线，直接对斜坡进行抬升。

  
## 转移装置模块

<img width="690" height="312" alt="image" src="https://github.com/user-attachments/assets/de4027d8-9181-45ca-93d5-ac78210e77c6" />
=====
  功能描述：MG995舵机固连仓库，舵机90°翻转实现仓库的倾倒功能；马达带动齿轮旋转，经齿条转化为平动实现仓库上升和下降的功能。<br>
    
=====
  开发历程：<br>
 10月19日初步方案：第一代转移装置是直接利用舵机将仓库倾倒，问题在于此转移装置实现的前提（能够将2号小车里面的小球转移到1号小车）是仓库足够的高，考虑到仓库足够的高的话对收集装置的设计会比较困难。<br>
  10月20日到10月22日迭代优化方案：第二代方案我们换成了利用两个舵机实现对收集装置的抬升，随后又还是觉得麻烦，所以我们的第三代收集装置是利用一个TT马达牵引两根线，直接对斜坡进行抬升。
  
## 机械臂模块

<img width="864" height="496" alt="image" src="https://github.com/user-attachments/assets/f53b0147-44ac-42c4-bb3e-dcf3fb33fa2c" />

<img width="539" height="718" alt="image" src="https://github.com/user-attachments/assets/07f26611-21f8-4688-9a03-9434cc9cd3ce" />
<br>
=====
  功能描述：此机械臂拥有两大功能，一是实现对台阶上的小球的扒拉作用，二是实现对敌方小车的阻挡作用。<br>
    
=====
  开发历程：
  10月23日到10月24日：构思并建模。
## 主程序操作系统模块
===== 
  功能描述：优化小车的工作模式，充分利用小车的硬件资源。<br>
    
=====
  开发历程：<br>
  10月8日：遇到的问题一:<br>
  如何实现各模块之间的独立编写与协同合作。<br>
  解决方案：<br>
  经过讨论，主程序不直接参与硬件设置，每个模块设置了几个接口函数负责数据的传输，具体的硬件控制的功能在接口函数中调用该模块对应函数实现。各个模块的负责人将相关函数编好打包为头文件，上传到工程中<br>
  10月8日：遇到的问题二：<br>
  有人学HAL库，有人学标准库，用的库不统一。<br>
  解决方案：<br>
  由于HAL库有系统自动生成的代码，不清楚原理的话不太好把这个模块打包为头文件，可能会缺点什么东西，又考虑到标准库有点繁琐，就手动把标准库一些常用功能分装打包成便于调用的函数，比如gpio口的配置，定时器的配置等，这样就可以降低标准库的使用难度，便于合作，统一标准。<br>
  10月23日：遇到的问题三：<br>
  在进行机械臂等需要舵机的外设的编程时，发现定时器不够用的问题。<br>
  解决方案：<br>
  从SPI软件模拟获得启发，结合延时函数，用软件模拟需要的PWM波形。<br>
  10月25日：遇到的问题四：<br>
  在把机械臂等模块并入主程序时，发现小车死机了，经过debug，发现问题在延时函数上。<br>
  解决方案：<br>
  经过debug发现，PS_EXIT_INIT()之后的不在中断里的延时函数都会让程序崩溃，查阅资料后，发现基于硬件的延时函数不能和中断同时使用。于是重写了一个基于软件的延时函数，解决了该问题，并记住了这个教训。<br>
